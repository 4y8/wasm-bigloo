(module dead-func-elim
   (export dfe-prog)
   (main main))

;; todo : + (global.set x ...) doesn't use x
;;        + eliminate dead types
;;        + eliminate duplicate data

(define (wasm-pp l #!key (scheme-string #t))
   (define (pp-args l)
      (for-each (lambda (n)
		   (display " ")
		   (pp n))
	 l))

   (define (char-visible? c)
      (and (char>=? c #\x20)
	   (char<? c #\x7F) ;; exclude the DEL character (illegal in WASM text format)
	   (not (char=? c #\"))
	   (not (char=? c #\\))))

   (define (dump-scheme-string s)
      (let ((l (string-length s)))
	 (let loop ((i 0))
	    (when (<fx i l)
	       (let ((c (string-ref s i))
		     (hex "0123456789abcdef"))
		  (cond
		     ((char-visible? c)
		      (display c)
		      (loop (+fx i 1)))
		     ((char=? c #\")
		      (display "\\22")
		      (loop (+fx i 1)))
		     ((char=? c #\\)
		      (display "\\5c")
		      (loop (+fx i 1)))
		     ((char=? c #\newline)
		      (display "\\0a")
		      (loop (+fx i 1)))
		     (else
		      (let ((n (char->integer c)))
			 (display "\\")
			 (display (string-ref hex (bit-rsh n 4)))
			 (display (string-ref hex (bit-and n #xf)))
			 (loop (+fx i 1))))))))))

   (define (dump-string s)
      (display "\"")
      (if scheme-string
	  (dump-scheme-string s)
	  (display s))
      (display "\""))

   (define (pp-arg a)
      (cond
	 ((elong? a) (display a))
	 ((llong? a) (display a))
	 ((bignum? a) (display a))
	 ((string? a) (dump-string a))
	 (else (write a))))

   (define (pp-0 l)
      (display "(")
      (write (car l))
      (pp-args (cdr l))
      (display ")"))

   (define (pp-1 l)
      (display "(")
      (write (car l))
      (display " ")
      (pp-arg (cadr l))
      (pp-args (cddr l))
      (display ")"))

   (define (pp-2 l)
      (display "(")
      (write (car l))
      (display " ")
      (pp-arg (cadr l))
      (display " ")
      (pp-arg (car (cddr l)))
      (pp-args (cdr (cddr l)))
      (display ")"))

   (define (pp-oneline l)
      (display "(")
      (write (car l))
      (for-each (lambda (a) (display " ") (pp-arg a)) (cdr l))
      (display ")"))

   (define (pp l)
      (cond
	 ((pair? l)
	  (case (car l)
 	     ((import) (pp-2 l))
	     ((func) (pp-1 l))
	     ((type) (pp-1 l))
	     ((sub) (pp-1 l))
	     ((global) (pp-1 l))
	     ((memory) (pp-oneline l))
	     ((data) (pp-1 l))
	     ((elem) (pp-oneline l))
	     ((export) (pp-oneline l))
	     ((param) (pp-oneline l))
	     ((result) (pp-oneline l))
	     ((local) (pp-oneline l))
	     ((field) (pp-oneline l))
	     ((mut) (pp-oneline l))
	     ((i32.const) (pp-oneline l))
	     ((i64.const) (pp-oneline l))
	     ((f32.const) (pp-oneline l))
	     ((f64.const) (pp-oneline l))
	     ((ref) (pp-oneline l))
	     ((ref.null) (pp-oneline l))
	     ((local.get) (pp-oneline l))
	     ((global.get) (pp-oneline l))
	     ((local.set) (pp-1 l))
	     ((global.set) (pp-1 l))
	     ((br) (pp-oneline l))
	     ((unreachable) (pp-oneline l))
	     ((block) (if (symbol? (cadr l)) (pp-1 l) (pp-0 l)))
	     ((loop) (if (symbol? (cadr l)) (pp-1 l) (pp-0 l)))
	     ((call) (pp-1 l))
	     ((return_call) (pp-1 l))
	     ((call_ref) (pp-1 l))
	     ((return_call_ref) (pp-1 l))
	     ((struct.new) (pp-1 l))
	     ((struct.get) (pp-2 l))
	     ((array.get) (pp-1 l))
	     ((array.new) (pp-1 l))
	     ((array.new_elem) (pp-2 l))
	     (else (pp-0 l))))
	 ((not l) 'nothing)
	 (else (pp-arg l))))
   (pp l))

(define (remove-type-use block)
   (match-case block
      (((export . ?-) . ?rst)
       (remove-type-use rst))
      (((type ?-) . ?rst)
       (remove-type-use rst))
      (((param . ?-) . ?rst)
       (remove-type-use rst))
      (((result ?-) . ?rst)
       (remove-type-use rst))
      (else block)))

(define (remove-locals block)
   (match-case block
      (((local . ?-) . ?rst)
       (remove-locals rst))
      (else block)))

(define (name-of-module m)
   (match-case m
      ((import ?- ?- (or (func ?x . ?-) (table ?x . ?-)
                          (memory ?x . ?-) (global ?x . ?-)))
       x)
      ((func ?x . ?-) x)
      ((global ?x . ?-) x)
      ((tag ?x . ?-) x)
      ((data ?x . ?-) x)))

(define (build-table p)
   (let* ((table (make-hashtable))
          (kept (make-hashtable))
          (add
           (lambda (m)
             (match-case m
                ((or (import ?- ?- (or (func ?x . ?-) (table ?x . ?-)
                                       (memory ?x . ?-) (global ?x . ?-)))
                     (func ?x . ?-)
                     (global ?x . ?-)
                     (tag ?x . ?-)
                     (data ?x . ?-))
                 (hashtable-put! table x m))
                ((or (export . ?-) (type . ?-) (memory . ?-) (rec . ?-))
                 (hashtable-put! kept m '()))))))
     (for-each add p)
     (values table kept)))

(define (explore-instr! visited table i)
   (let ((go (lambda (i)
               (explore-instr! visited table i))))
      (match-case i
         ((? symbol?)
          (if (hashtable-contains? table i)
              (explore! visited table i)))
         ((?- . ?rst)
          (for-each go rst)))))

(define (explore! visited table x)
   (when (and (hashtable-contains? table x) (not (hashtable-contains? visited x))
      (let ((m (hashtable-get table x))
            (go (lambda (x) (explore-instr! visited table x))))
         (hashtable-put! visited x m)
         (match-case m
            ((func ?- . ?rst)
             (for-each go (remove-locals (remove-type-use rst))))
            ((global ?- . ?rst)
             (for-each go rst)))))))

(define (dfe-prog p)
   (match-case p
      ((module ?nm . ?p)
       (multiple-value-bind (prog-table kept)
           (build-table p)
           (let ((visited (make-hashtable)))
              (explore! visited prog-table '$main)
              (for-each (match-lambda
                           ((export ?- (func ?f))
                            (explore! visited prog-table f))) p)
              (for-each (lambda (m)
                           (let ((name (name-of-module m)))
                              (if (or (hashtable-contains? visited name)
                                      (hashtable-contains? kept m))
                                  (wasm-pp m)))) p))))))

(define (main argv)
   (call-with-input-file (cadr argv)
      (lambda (port)
         (with-output-to-file "out.wat"
            (lambda ()
               (dfe-prog (read port)))))))
