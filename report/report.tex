\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{bigfoot}
\usepackage[english]{babel}
\usepackage[a4paper, left=1.2in, right=1.2in]{geometry}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{report/report.bib}
\author{Aghilas Y. Boussaa \texttt{<aghilas.boussaa@ens.fr>}}

\title{\textsf{watib}: Design and implementation of an optimising WebAssembly toolchain}
\begin{document}
\maketitle
\begin{abstract}
  We describe watib: a WebAssembly Toolchain written In Bigloo. It has
  been integrated in the Bigloo Scheme compiler and is available as a standalone
  tool. It currently handles, parsing, validation (type checking), optimisation
  and assembly of files in WebAssembly Text format.
\end{abstract}

\section{Introduction}
\subsection{WebAssembly}
WebAssembly~\cite{haas2017bringing} is an assembly-like language for a
stack-based virtual machine. Its standard~\cite{WebAssemblyCoreSpecification3}
typing rules (validation), semantics, an abstract syntax and two concrete
syntaxes (formats) for the language. The binary format represents WebAssembly
modules as a sequence of bytes. It is taken as input by Wasm virtual machines
such as V8~\cite{V8} or SpiderMonkey~\cite{SpiderMonkey} and manipulated by
toolchains such as binaryen~\cite{Binaryen} or wasm-tools~\cite{WasmTools}. The
textual format represents WebAssembly modules as S-expressions. It is taken as
input by toolchains or written by humans (and compilers such as
Bigloo~\cite{Bigloo}).
\begin{figure}[h]
\centering
\begin{tabular}{c c c}
\begin{minipage}{1.8in}
\begin{verbatim}
(func $add
  (param $x i32)
  (param $y i32)
  (result i32)
  (i32.add (local.get $x)
           (local.get $y)))
\end{verbatim}
\end{minipage}&
\begin{minipage}{1.6in}
\begin{verbatim}
(type $pair
  (struct
    (field $car
      (mut (ref eq)))
    (field $cdr
      (mut (ref eq)))))
\end{verbatim}
\end{minipage}
&\begin{minipage}{1.8in}
\begin{verbatim}
(func $get-car
  (param $x (ref eq))
  (result (ref eq))
  (struct.get $pair $car
    (ref.cast (ref $pair)
      (local.get $x))))
\end{verbatim}
\end{minipage}
\end{tabular}
\caption{Examples of WebAssembly in textual format}
\end{figure}

We review some of the characteristics of WebAssembly that influenced the design
of watib.

\begin{description}
\item[Strong statical typing]
WebAssembly is strongly and statically typed. Watib thus performs a phase of
type-checking (called validation in WebAssembly language). Typing information
appears in the binary format (on blocks for instance). Watib preserves it during
all of its phases. In particular, all optimisations are type preserving and they
code the introduce is well-typed and annotated.

\item[Structured control flow]
All control flow in WebAssembly is structured: the language forbids arbitrary
jumps. Branching can only go to a parent block (at the beginning or at the end
depending on the block's nature, see figure~\ref{cf-ex}).

\item[Typed labels]
Combining the two previous points implie that all labels are typed. Blocks take
values on the stack as input and leave values on the stack as outputs. The types
of the branching instructions ensure that blocks get the expected values on the
stack.
\end{description}
\begin{figure}[h]
\centering
\begin{tabular}{c c c}
\begin{minipage}{1.8in}
\begin{verbatim}
(block $l
  (result i32)
  (if (i32.const 1)
    (then
      (i32.const 42)
      (br $l)))
  (i32.const 67))
\end{verbatim}
\end{minipage}&
\begin{minipage}{1.8in}
\begin{verbatim}
(i32.const 1)
(loop $l
  (param $i32)
  (if
    (then
      (br $l
        (call $cnt)))))
\end{verbatim}
\end{minipage}
&\begin{minipage}{1.8in}
\begin{verbatim}
(block $l
  (result (ref $pair))
  (br_on_cast $l
    (ref eq)
    (ref $pair)
    (local.get $x))
  (unreachable))
\end{verbatim}
\end{minipage}
\end{tabular}
\caption{Examples of WebAssembly control flow}\label{cf-ex}
\end{figure}
\subsection{Watib}
Watib handles type checking, optimisation and assembly of Wasm programs given in
textual format\footnote{binary format support as input is planned}. We review
some differences between watib and already existing toolchains (apart from its
lack of features and overall maturity).
\begin{description}
\item[Fault tolerance] For the sake of user-friendliness, watib can recover from
  most validation errors (and some syntax errors). It avoids having to correct
  errors one by one which can be tedious for big files.
\item[Linear IR] The other toolchain aiming at providing sophisticated
  optimisations, binaryen, has a tree like IR, in part, for historical
  reasons~\cite{BinaryenIR}. When the development of binaryen started, Wasm
  wasn't stack based and features such as multiple return values or block
  parameters weren't adopted. They remain second class citizens in
  binaryen\footnote{for instance, the following piece of code is assembled to a
  code using local variables to avoid having a block parameter:
\begin{verbatim}(i32.const 0)
(block (param i32)
  (i32.const 0) (i32.add) (drop))
\end{verbatim}
}. Watib's IR is closer to modern Wasm. See~\ref{ir} for more details. We hope
  that will enable different optimisations.
\end{description}
\section{Validation}
\section{Optimisation}
\subsection{The Intermediate Representation}\label{ir}
\subsection{Optimisations}
\printbibliography
\end{document}
