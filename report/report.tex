\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[a4paper, left=1.2in, right=1.2in]{geometry}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{report/report.bib}
\author{Aghilas Y. Boussaa \texttt{<aghilas.boussaa@ens.fr>}}

\title{\textsf{watib}: Design and implementation of an optimising WebAssembly toolchain}
\begin{document}
\maketitle
\begin{abstract}
  We describe watib: a WebAssembly Toolchain written In Bigloo. It has
  been integrated in the Bigloo Scheme compiler and is available as a standalone
  tool. It currently handles, parsing, validation (type checking), optimisation
  and assembly of files in WebAssembly Text format.
\end{abstract}

\section{Introduction}
\subsection{WebAssembly}
WebAssembly~\cite{haas2017bringing} is an assembly-like language for a
stack-based virtual machine. Its standard~\cite{WebAssemblyCoreSpecification3}
typing rules (validation), semantics, an abstract syntax and two concrete
syntaxes (formats) for the language. The binary format represents WebAssembly
modules as a sequence of bytes. It is taken as input by Wasm virtual machines
such as V8~\cite{V8} or SpiderMonkey~\cite{SpiderMonkey} and manipulated by
toolchains such as binaryen~\cite{Binaryen} or wasm-tools~\cite{WasmTools}. The
textual format represents WebAssembly modules as S-expressions. It is taken as
input by toolchains or written by humans (and compilers such as
Bigloo~\cite{Bigloo}).
\begin{figure}[h]
\centering
\begin{tabular}{c c c}
\begin{minipage}{1.8in}
\begin{verbatim}
(func $add
  (param $x i32)
  (param $y i32)
  (result i32)
  (i32.add (local.get $x)
           (local.get $y)))
\end{verbatim}
\end{minipage}&
\begin{minipage}{1.6in}
\begin{verbatim}
(type $pair
  (struct
    (field $car
      (mut (ref eq)))
    (field $cdr
      (mut (ref eq)))))
\end{verbatim}
\end{minipage}
&\begin{minipage}{1.8in}
\begin{verbatim}
(func $get-car
  (param $x (ref eq))
  (result (ref eq))
  (struct.get $pair $car
    (ref.cast (ref $pair)
      (local.get $x))))
\end{verbatim}
\end{minipage}
\end{tabular}
\caption{Examples of WebAssembly in textual format}
\end{figure}

We review some of the characteristics of WebAssembly that influenced the design
of watib.

\begin{description}
\item[Strong statical typing] WebAssembly is strongly and statically typed.
  Watib thus performs a phase of type-checking (called validation in WebAssembly
  language). Typing information appears in the binary format (on blocks for
  instance). Watib preserves it during all of its phases. In particular, all
  optimisations are type preserving and they code the introduce is well-typed
  and annotated. This typing discipline also implies that all down casts are
  explicit. The optimisation phase tries to remove all the useless ones and
  restructures the control flow to eliminate some redundant tests and casts.
  This is made possible by the fact that WebAssembly branching can depend on
  type information. This optimisation is described in~\ref{broncast}.

%% \item[Structured control flow] All control flow in WebAssembly is structured:
%%   the language forbids arbitrary jumps. Branching can only go to a parent block
%%   (at the beginning or at the end depending on the block's nature, see
%%   figure~\ref{cf-ex}).

\item[Typed labels]
Combining the two previous points implie that all labels are typed. Blocks take
values on the stack as input and leave values on the stack as outputs. The types
of the branching instructions ensure that blocks get the expected values on the
stack.
\end{description}
\begin{figure}[h]
\centering
\begin{tabular}{c c c}
\begin{minipage}{1.8in}
\begin{verbatim}
(block $l
  (result i32)
  (if (i32.const 1)
    (then
      (i32.const 42)
      (br $l)))
  (i32.const 67))
\end{verbatim}
\end{minipage}&
\begin{minipage}{1.8in}
\begin{verbatim}
(i32.const 1)
(loop $l
  (param $i32)
  (if
    (then
      (br $l
        (call $cnt)))))
\end{verbatim}
\end{minipage}
&\begin{minipage}{1.8in}
\begin{verbatim}
(block $l
  (result (ref $pair))
  (br_on_cast $l
    (ref eq)
    (ref $pair)
    (local.get $x))
  (unreachable))
\end{verbatim}
\end{minipage}
\end{tabular}
\caption{Examples of WebAssembly control flow}\label{cf-ex}
\end{figure}
\subsection{Watib}
Watib handles type checking, optimisation and assembly of Wasm programs given in
textual format\footnote{binary format support as input is planned}. Function
validation and optimisation is parallelisable. We added the option to run them
in an arbitrary number of threads. This feature, and thus the dependency on
pthreads is optional which is requiered for integration with Bigloo. We review
some differences between watib and already existing toolchains (apart from its
lack of features and overall maturity).
\begin{description}
\item[Fault tolerance] For the sake of user-friendliness, watib can recover from
  most validation errors (and some syntax errors). It avoids having to correct
  errors one by one which can be tedious for big files.
\item[Linear IR] The other toolchain aiming at providing sophisticated
  optimisations, binaryen, has a tree like IR, in part for historical
  reasons~\cite{BinaryenIR}. When the development of binaryen started, Wasm
  wasn't stack based and features such as multiple return values or block
  parameters weren't adopted. These features remain second class citizens in
  binaryen\footnote{for instance, code using block parameters is assembled to
  code using local variables instead by binaryen's \textsf{wasm-as}}. Watib's IR
  is closer to modern Wasm. See~\ref{ir} for more details. We hope that will
  enable different optimisations and a better treatment of code written using
  WebAssembly's new features.
\end{description}
\section{Validation}
\section{Optimisation}
\subsection{The Intermediate Representation}\label{ir}
\subsection{Optimisations}
Watib performs several optimisation passes. We start by reviewing optimisations
which benefit the others, by giving more precise information or removing
generated useless code.
\begin{description}
  \item[Copy Propagation] When a variable $x$ is assigned the value of another
    variable $y$, we replace references to $x$ with references to $y$, until the
    next assignement to $x$ or $y$.
  \item[Pure Drops Elimination] We eliminate \textsf{drop} instructions and
    their argument when it has no side effect. We try to remove as extra
    computation as possible by inserting as much \textsf{drop} as needed.
  \item[Constant Folding] We evaluate some expressions whose value is known at
    compile time. We also also remove conditional branching when the condition
    is constant.
  \item[Unreachable Code Elimination] We eliminate some instructions that are
    known to never execute (after a \textsf{return} for instance). However, some
    unreachable code may be needed for validation, even though it can't be
    executed, see~\ref{unreachable} for an example. When well-typedness without
    the unreachable instructions can't easily be guaranteed, an
    \textsf{unreachable} instruction is inserted instead.
  \item[Peephole optimisation] We recognise small patterns in Wasm code and
    replace them with equivalent code that should be smaller or faster.
\begin{figure}[h]
\centering
\begin{tabular}{c c}
\begin{minipage}{2.8in}
\begin{verbatim}
(func $f
  (result i32)
  (if (i32.const 1)
    (then (return (i32.const 0)))
    (else (return (i32.const 1)))))
\end{verbatim}
\end{minipage}
&\begin{minipage}{2.8in}
\begin{verbatim}
(func $f
  (result i32)
  (if (i32.const 1)
    (then (return (i32.const 0)))
    (else (return (i32.const 1))))
  (unreachable))
\end{verbatim}
\end{minipage}
\end{tabular}
\caption{The function on the left is ill-typed while the function on the right
  is well-typed}\label{unreachable}
\end{figure}
  \item[Type propagation] This one is not an optimisation \emph{per se}. It only
    refines type annotations of variables in the IR. When a variable is assigned
    a value, the type of this value (which may be a strict subtype of the
    variable's declared type) is set as the actual output type of each variable
    access, until it is modified.
\end{description}

We, now, review more Wasm-specific optimisations and detail in which way they
use the previous ones.
\subsubsection{Cast Elimination}
We eliminate redundant casts and replace type tests by constants if their result
can be determined.

\subsubsection{\textsf{br\_on\_cast} Introduction}\label{broncast}
\printbibliography
\end{document}
