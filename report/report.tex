\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[a4paper, left=1.2in, right=1.2in]{geometry}
\usepackage{calc}

\usepackage{amsmath}
\DeclareMathOperator{\reft}{\textsf{ref}}
\DeclareMathOperator{\refnullt}{\textsf{ref null}}

\usepackage[backend=bibtex,style=alphabetic]{biblatex}
\addbibresource{report/report.bib}
\author{Aghilas Y. Boussaa \texttt{<aghilas.boussaa@ens.fr>}}

\title{\textsf{watib}: Design and implementation of an optimising WebAssembly
  toolchain}
\begin{document}
\maketitle
\begin{abstract}
  WebAssembly (Wasm) is a code format aiming at providing efficient execution.
  It now offers the features needed to be a compilation target for functional
  programming languages such as Scheme. Such a backend has been developped in
  the Bigloo compiler, relying on an external toolchain.

  We present \textsf{watib}, a WebAssembly Toolchain written In Bigloo. It has
  been integrated in the Bigloo Scheme compiler and is available as a standalone
  tool. We present \textsf{watib}'s architecture and compare our toolchain with
  the one used before.
\end{abstract}

\section{Introduction}
In 2024, a Wasm backend was added to the Bigloo~\cite{Bigloo} scheme compiler.
It generated textual Wasm and relied on an external tool for the assembly. Watib
was developped as a replacement for this tool and has been directly integrated
in the Bigloo compiler. It is also available as a standalone tool with a
command-line interface.

The rest of this section gives a high-level overview of WebAssembly and
\textsf{watib}. Section~\ref{val} details \textsf{watib}'s typechecker.
Section~\ref{opt} describes the design of the different optimisation passes and
the overall design of the optimiser. We omit the assembly phase as, once we have
an intermediate representation, it is a straightforward transcription of the
specification.
\subsection{WebAssembly}
WebAssembly~\cite{haas2017bringing} is an assembly-like language for a
stack-based virtual machine. It aims at providing a fast, safe and portable
language endowed with a portable and efficient representation. New compilers
targetting Wasm are developped~\cite{emscripten, kotlin, ocaml}.

The WebAssembly standard~\cite{WebAssemblyCoreSpecification3} specifies typing
rules (validation), semantics, an abstract syntax and two concrete syntaxes
(formats) for the language. The binary format represents WebAssembly modules as
a sequence of bytes. It is taken as input by Wasm virtual machines such as
V8~\cite{V8} or SpiderMonkey~\cite{SpiderMonkey} and manipulated by toolchains
such as binaryen~\cite{Binaryen} or wasm-tools~\cite{WasmTools}. The textual
format represents WebAssembly modules as S-expressions. It is taken as input by
toolchains or written by humans (and compilers such as Bigloo).

The third version of the standard the standard adds features facilitating
compiling from functional languages. For instance, Wasm has now a garbage
collector, instructions for tail-calls (they are needed because the language
doesn't support goto) and exceptions. This version is still in draft, but the
mentionned features are stable and already implemented by the major Wasm
engines. Bigloo's Wasm backend relies on these features. They are demonstrated
in the example of figure~\ref{ex}.

\begin{figure}[h]
  \begin{minipage}{\widthof{(type \$pair (sub \$pair-nil (struct (field \$cdr (ref \$pair-nil))}}
\begin{verbatim}
(type $pair-nil (sub (struct)))
(type $pair (sub $pair-nil (struct (field $cdr (ref $pair-nil))
                                   (field $car i32))))
(func $find-zero
  (param $l (ref $pair-nil))
  (result i32)
  (if (ref.test (ref $pair) (local.get $l))
    (then
      (if (i32.eqz (struct.get $pair $car
                     (ref.cast (ref $pair) (local.get $l))))
        (then (return (i32.const 1)))
        (else
          (return_call $find-zero
            (struct.get $pair $cdr
              (ref.cast (ref $pair) (local.get $l)))))))
    (else (return (i32.const 0))))
  (unreachable))
\end{verbatim}
  \end{minipage}

  \caption{A Wasm function testing if a list of integers contains 0}\label{ex}
\end{figure}

\subsection{Watib}
\textsf{Watib} handles type checking (the \texttt{Val} folder of the sources),
optimisation (the \texttt{Opt} folder) and assembly (the \texttt{Asm} folder) of
Wasm programs given in textual format\footnote{binary format support as input is
planned}. Function validation and optimisation is parallelisable. We added the
option to run them in an arbitrary number of threads. This feature, and thus the
dependency on pthreads is optional which is requiered for integration with
Bigloo.

The WebAssembly platform is in constant evolution. Features are added to the
engines before they are standardised. Thus potential users might want to be able
to use them as soon as possible. Long-term maintenance is one of our goals.
\textsf{Watib} has been designed to be able to keep up with the additions made
to the language. Adding a instruction that isn't a block can be done by putting
a new entry in the list of opcodes (\texttt{Asm/opcodes.sch}) and in the list of
validation rules (\texttt{Val/instruction-types.sch}). The case of block
instructions is more involved as they have syntaxes different from the other
ones. The optimisation passes also have to be modified to take into account the
new control flow possibilities. It should not be a problem because new kinds of
blocks aren't often introduced.

We now review some differences between \textsf{watib} and already existing
toolchains (apart from the lack of features and maturity of the former).
\subsubsection{Fault tolerance}
For the sake of user-friendliness, \textsf{watib} can recover from most
validation errors (and some syntax errors). It avoids having to correct errors
one by one which can be tedious for big files, as parsing alone can be time
consuming. We try to give informative error messages.

\subsubsection{{Zealous\protect\footnotemark} respect of the spec}
Binaryen's assembler, \textsf{wasm-as}, accepts files that do not conform to the
specification and outputs file that are more or less semantically equivalent. We
compiled in watib's internal documentation a list of the modifications made by
\textsf{wasm-as} we witnessed~\cite{WasmAsExtension}. It is reproduced in
appendix~\ref{wasmasex}. For the sake of portability, watib follows the
specification by default. A compatibility mode with \textsf{wasm-as} is
planned.\footnotetext{in fact, the proofreading induced by the cautious study of
  the spec resulted in a dozen (minor) pull requests and issue reports to the
  specification's draft}

Before the introduction of watib, Bigloo's Wasm backend was generating code
ill-typed according to the standard but which was still accepted by
\textsf{wasm-as}, without any warning. In fact, the original implementation of
exceptions was incorrect and a validation following the specification would have
pointed a problem.

\subsubsection{Linear IR}
The other toolchain aiming at providing sophisticated optimisations, binaryen,
has a tree like IR, in part for historical reasons~\cite{BinaryenIR}. When the
development of binaryen started, Wasm wasn't stack based and features such as
multiple return values or block parameters weren't adopted. These features
remain second class citizens in binaryen\footnote{for instance, code using block
parameters is assembled to code using local variables instead by binaryen's
\textsf{wasm-as}}. Watib's IR is closer to modern Wasm. See~\ref{ir} for more
details. We hope that will enable different optimisations and a better treatment
of code written using WebAssembly's new features.
\section{Validation}\label{val}
We start by giving an overview of WebAssembly's type system, and then describe
our implementation of it.
\subsection{WebAssembly's type system}
%% condense ?
The main types used in Wasm are:
\begin{description}
  \item[Value types] They represent values on the stack and arguments to
    function. A \emph{value type} can be either numeric (\textsf{i32},
    \textsf{f64}, etc.), vector (\textsf{v128}) or a \emph{reference type}.
  \item[Reference types] They represent pointers to objects on the heap whose
    types are \emph{heap types}. A reference can be either \emph{nullable} or
    not. The two types are represented respectively as $\refnullt ht$ and $\reft
    ht$, where $ht$ is the heap type pointed to.
  \item[Heap types] They represent objects on the heap. They can be either a
    type index refering to a \emph{composite type}, in which case the heap type
    is concrete, or an abstract heap type.
  \item[Composite types] They represent concrete objects on the heap. They are:
    \begin{description}
      \item[function types] types of a function represented by the types of its
        inputs and its ouptuts (two vectors of value types),
      \item[array types] types of an array represented by the type of its
        elements which is a \emph{field type} (either a value type or a packed
        type: \textsf{i8} or \textsf{i16}, the whole decorated by a mutability
        declaration),
      \item[structure types] types of a structure represented the field types of
        its fields
    \end{description}
  \item[Abstract heap types] They mostly represent (formal) unions and
    intersections of the previous ones:
    \begin{description}
      \item[\textsf{func}] the smallest supertype of all \emph{function types},
      \item[\textsf{array}] the smallest supertype of all \emph{array types},
      \item[\textsf{struct}] the smallest supertype of all \emph{structure
      types},
      \item[\textsf{exn}] the type of all exception references,
      \item[\textsf{i31}] denotes unboxed scalars as tagged pointers, i.e. a
        value of type \textsf{ref i31} is not a reference but a 31-bit integer,
        it is distinguished from regular references by the interpreter using a
        1-bit tag,
      \item[\textsf{eq}] the type of all objects whose references can be
        compared: either structures, arrays or unboxed integers,
      \item[\textsf{extern}] the type of references passed by the embedder,
      \item[\textsf{any}] a supertype of \textsf{eq} that also contains all
        objects of type \textsf{extern} that were internalised (i.e. now
        considered as Wasm objects).
    \end{description}
    Abstract heap types can also be dual of the previous ones: \textsf{nofunc}
    is the largest subtype of all function types, \textsf{none} is the largest
    subtype of all array and structure types, \textsf{noexn} is the largest
    subtype of the types of expection reference and \textsf{noextern} is the
    largest subtype of types of all extern references. These types aren't
    inhabited, but nullable references to them are (they contain the null
    pointer).

\end{description}

WebAssembly's type system supports \emph{declared and mutually iso-recursive
subtyping}.

Subtyping rules relating abstract heap types to the concrete ones and abstract
ones with each other have already been given, as part of their definitions,
to which we add transitivity.

Wasm's subtyping is \emph{declared} as the subtyping relations between the
defined types have to be specified as part of the type defintion. Their validity
can be checked with the type definition's validation.

We now give the intuition behind \emph{mutually iso-recursive subtyping}.
See~\cite{rossberg2023mutually} for a full discussion.
\subsection{A type checker for WebAssembly}
\section{Optimisation}\label{opt}
\subsection{The Intermediate Representation}\label{ir}
\subsection{Optimisations}
Watib performs several optimisation passes. We start by reviewing optimisations
which benefit the others, by giving more precise information or removing
generated useless code.
\begin{description}
  \item[Copy Propagation] When a variable $x$ is assigned the value of another
    variable $y$, we replace references to $x$ with references to $y$, until the
    next assignement to $x$ or $y$. We were inspired
    by~\cite[Section~12.5]{muchnick1997advanced} approach.
  \item[Pure Drops Elimination] We eliminate \textsf{drop} instructions and
    their argument when it has no side effect. We try to remove as extra
    computation as possible by inserting as much \textsf{drop} as needed.
  \item[Constant Folding] We evaluate some expressions whose value is known at
    compile time. We also also remove conditional branching when the condition
    is constant.
  \item[Unreachable Code Elimination] We eliminate some instructions that are
    known to never execute (after a \textsf{return} for instance). However, some
    dead code may be needed for validation, even though it can't be executed,
    see~\ref{unreachable} for an example. When well-typedness without the dead
    instructions can't easily be guaranteed, an \textsf{unreachable} instruction
    is inserted instead of the dead code.
  \item[Peephole optimisation] We recognise small patterns in Wasm code and
    replace them with equivalent code that should be smaller or faster.
\begin{figure}[h]
\centering
\begin{tabular}{c c}
\begin{minipage}{2.8in}
\begin{verbatim}
(func $f
  (result i32)
  (if (i32.const 1)
    (then (return (i32.const 0)))
    (else (return (i32.const 1)))))
\end{verbatim}
\end{minipage}
&\begin{minipage}{2.8in}
\begin{verbatim}
(func $f
  (result i32)
  (if (i32.const 1)
    (then (return (i32.const 0)))
    (else (return (i32.const 1))))
  (unreachable))
\end{verbatim}
\end{minipage}
\end{tabular}
\caption{The function on the left is ill-typed while the function on the right
  is well-typed}\label{unreachable}
\end{figure}
  \item[Type propagation] This one is not an optimisation \emph{per se}. It only
    refines type annotations of variables in the IR. When a variable is assigned
    a value, the type of this value (which may be a strict subtype of the
    variable's declared type) is set as the actual output type of each variable
    access, until it is modified.
\end{description}

Most optimisations passes described earlier are general, in the sense that they
are applied in most optimising compilers~\cite{muchnick1997advanced}. We, now,
review more Wasm-specific optimisations and detail in which way they use the
previous ones.
\subsubsection{Cast Elimination}
We eliminate redundant casts and replace type tests by constants if their result
can be determined.

\subsubsection{Type-Dependent Control Flow Rewriting}\label{broncast}

\printbibliography
\newpage
\appendix
\section{Wasm-as' extensions to the specification}\label{wasmasex}
\end{document}
