(module binary
   (library srfi1)
   (main main)
   (import leb128))

;;; we currently miss table and elem - they are not used by bigloo

(define (fresh-var) (gensym "__bigloo_wasm_dummy_id_"))

(define *valtype-symbols* (make-hashtable))

(for-each (match-lambda ((?sym . ?code)
                         (hashtable-put! *valtype-symbols* sym code)))
          '((i32 . #x7F)
            (i64 . #x7E)
            (f32 . #x7D)
            (f64 . #x7C)
            (v128 . #x7B)
            ; these two are not valtypes but we do not validate
            (i8 . #x78)
            (i16 . #x77)
            (nofunc . #x73)
            (noextern . #x72)
            (none . #x71)
            (func . #x70)
            (exn . #x69)
            (extern . #x6F)
            (any . #x6E)
            (eq . #x6D)
            (i31 . #x6C)
            (struct . #x6B)
            (array . #x6A)))

(define *type-abbreviations* (make-hashtable))

(for-each (match-lambda ((?sym . ?code)
                         (hashtable-put! *type-abbreviations* sym code)))
          '((anyref . (ref null any))
            (eqref  . (ref null eq))
            (i31ref . (ref null i31))
            (structref . (ref null struct))
            (arrayref . (ref null array))
            (funcref . (ref null func))
            (exnref . (ref null exn))
            (externref . (ref null extern))
            (nullref . (ref null none))
            (nullfuncref . (ref null nofunc))
            (nullexternref . (reff null noextern))))

(define *simple-opcodes* (make-hashtable))

(for-each (match-lambda ((?sym . ?code)
                         (hashtable-put! *simple-opcodes* sym code)))
          '((unreachable . #x00)
            (nop . #x01)
            (throw_ref . #x0A)
            (return . #x0F)

            (drop . #x1A)

            (i32.eqz  . #x45)
            (i32.eq   . #x46)
            (i32.ne   . #x47)
            (i32.lt_s . #x48)
            (i32.lt_u . #x49)
            (i32.gt_s . #x4A)
            (i32.gt_u . #x4B)
            (i32.le_s . #x4C)
            (i32.le_u . #x4D)
            (i32.ge_s . #x4E)
            (i32.ge_u . #x4F)

            (i64.eqz  . #x50)
            (i64.eq   . #x51)
            (i64.ne   . #x52)
            (i64.lt_s . #x53)
            (i64.lt_u . #x54)
            (i64.gt_s . #x55)
            (i64.gt_u . #x56)
            (i64.le_s . #x57)
            (i64.le_u . #x58)
            (i64.ge_s . #x59)
            (i64.ge_u . #x5A)

            (f32.eq . #x5B)
            (f32.ne . #x5C)
            (f32.lt . #x5D)
            (f32.gt . #x5E)
            (f32.le . #x5F)
            (f32.ge . #x60)

            (f64.eq . #x61)
            (f64.ne . #x62)
            (f64.lt . #x63)
            (f64.gt . #x64)
            (f64.le . #x65)
            (f64.ge . #x66)

            (i32.clz    . #x67)
            (i32.ctz    . #x68)
            (i32.popcnt . #x69)
            (i32.add    . #x6A)
            (i32.sub    . #x6B)
            (i32.mul    . #x6C)
            (i32.div_s  . #x6D)
            (i32.div_u  . #x6E)
            (i32.rem_s  . #x6F)
            (i32.rem_u  . #x70)
            (i32.and    . #x71)
            (i32.or     . #x72)
            (i32.xor    . #x73)
            (i32.shl    . #x74)
            (i32.shr_s  . #x75)
            (i32.shr_u  . #x76)
            (i32.rotl   . #x77)
            (i32.rotr   . #x78)

            (i64.clz    . #x67)
            (i64.ctz    . #x68)
            (i64.popcnt . #x69)
            (i64.add    . #x6A)
            (i64.sub    . #x6B)
            (i64.mul    . #x6C)
            (i64.div_s  . #x6D)
            (i64.div_u  . #x6E)
            (i64.rem_s  . #x6F)
            (i64.rem_u  . #x70)
            (i64.and    . #x71)
            (i64.or     . #x72)
            (i64.xor    . #x73)
            (i64.shl    . #x74)
            (i64.shr_s  . #x75)
            (i64.shr_u  . #x76)
            (i64.rotl   . #x77)
            (i64.rotr   . #x78)

            (f32.abs      . #x8B)
            (f32.neg      . #x8C)
            (f32.ceil     . #x8D)
            (f32.floor    . #x8E)
            (f32.trunc    . #x8F)
            (f32.nearest  . #x90)
            (f32.sqrt     . #x91)
            (f32.add      . #x92)
            (f32.sub      . #x93)
            (f32.mul      . #x94)
            (f32.div      . #x95)
            (f32.min      . #x96)
            (f32.max      . #x97)
            (f32.copysign . #x98)

            (f64.abs      . #x99)
            (f64.neg      . #x9A)
            (f64.ceil     . #x9B)
            (f64.floor    . #x9C)
            (f64.trunc    . #x9D)
            (f64.nearest  . #x9E)
            (f64.sqrt     . #x9F)
            (f64.add      . #xA0)
            (f64.sub      . #xA1)
            (f64.mul      . #xA2)
            (f64.div      . #xA3)
            (f64.min      . #xA4)
            (f64.max      . #xA5)
            (f64.copysign . #xA6)

            (i32.wrap_i64        . #xA7)
            (i32.trunc_f64_s     . #xAA)
            (i32.trunc_f64_u     . #xAB)
            (i64.extend_i32_s    . #xAC)
            (i64.extend_i32_u    . #xAD)
            (i64.trunc_f64_s     . #xB0)
            (i64.trunc_f64_u     . #xB1)
            (f64.convert_i32_s   . #xB2)
            (f64.convert_i32_u   . #xB3)
            (f64.convert_i64_s   . #xB4)
            (f64.convert_i64_u   . #xB5)
            (f32.demote_f64      . #xB6)
            (f64.convert_i64_s   . #xB9)
            (f64.promote_f32     . #xBB)
            (i32.reinterpret_f32 . #xBC)
            (i64.reinterpret_f64 . #xBD)
            (f32.reinterpret_i32 . #xBE)
            (f64.reinterpret_i64 . #xBF)


            (ref.is_null     . #xD1)
            (ref.eq          . #xD3)
            (ref.as_non_null . #xD4)
            (array.len       . (#xFB 15))
            (ref.i31         . (#xFB 28))
            (i31.get_s       . (#xFB 29))
            (i31.get_u       . (#xFB 30))

            ; we do not support offset/alignment yet
            (i32.load8_s . (#x2C 0 4))
            (i32.load8_u . (#x2D 0 4))
            (i32.store8  . (#x3A 0 4))
            ))

(define (opcode? o)
   (and (symbol? o) (hashtable-contains? *simple-opcodes* o)))

(define *ref-instructions* (make-hashtable))

(for-each (match-lambda ((?sym . ?code)
                         (hashtable-put! *ref-instructions* sym code)))
          '((struct.new . 0)
            (struct.new_default . 1)
            (array.new . 6)
            (array.new_default . 7)
            (array.get . 11)
            (array.get_s . 12)
            (array.get_u . 13)
            (array.set . 14)
            (array.fill . 16)))

(define (ref-instruction-typeidx? i)
   (hashtable-contains? *ref-instructions* i))

;; actually it would be sufficient to check if the first character of the
;; symbol, is a $ or not
(define (valtype-symbol? s)
   (and (symbol? s) (hashtable-contains? *valtype-symbols* s)))

(define (type-abbreviation? s)
   (and (symbol? s) (hashtable-contains? *type-abbreviations* s)))

(define (wnumber? n)
   (cond ((number? n) #t)
         ((eq? n 'inf) #t)
         ((eq? n '-inf) #t)
         ((eq? n 'nan) #t)
         ((symbol? n)
          (let ((s (symbol->string n)))
             (if (and (>= (string-length s) 2) (substring-at? s "0x" 0))
                 (string->number (substring s 2) 16)
                 #f)))
         (#t #f)))

(define (wnumber->number n)
   (cond ((number? n) n)
         ((eq? n 'inf) +inf.0)
         ((eq? n '-inf) -inf.0)
         ((eq? n 'nan) +nan.0)
         (#t
          (string->number (substring (symbol->string n) 2) 16))))

(define (idx? x)
   (or (symbol? x) (number? x)))

(define (get-results l)
   (match-case l
      (((result . ?t) . ?rst)
       (multiple-value-bind (r tl)
          (get-results rst)
          (values (append t r) tl)))
      (else (values '() l))))

; decomposes a typeuse by separating parameters (types and names), results (only
; types) and the rest ; it generates dummy names to complete the list if
; necessary
(define (get-names/params/results/tl l)
   (match-case l
      (((param (and (? symbol?) ?name (not (? valtype-symbol?))) ?t) . ?rst)
       (multiple-value-bind (n p r tl)
          (get-names/params/results/tl rst)
          (values (cons name n) (cons t p) r tl)))
      (((param . ?t) . ?rst)
       (multiple-value-bind (n p r tl)
          (get-names/params/results/tl rst)
          (values (append (map (lambda (-) (fresh-var)) t) n)
                  (append t p) r tl)))
      (else
       (multiple-value-bind (r tl) (get-results l) (values '() '() r tl)))))

(define (get-typeidxs/comptype l)
  (match-case l
     ((?ct) (values '() ct))
     ((?x . ?rst)
      (multiple-value-bind (idxs ct)
         (get-typeidxs/comptype rst)
         (values (cons x idxs) ct)))))

(define (get-catches/tl l)
   (match-case l
      (((catch ?x ?l) . ?rst)
       (multiple-value-bind (c tl)
          (get-catches/tl rst)
          (values (cons (cons #x00 (cons x l)) c) tl)))
      (((catch_ref ?x ?l) . ?rst)
       (multiple-value-bind (c tl)
          (get-catches/tl rst)
          (values (cons (cons #x01 (cons x l)) c) tl)))
      (((catch_all ?l) . ?rst)
       (multiple-value-bind (c tl)
          (get-catches/tl rst)
          (values (cons (cons #x02 l) c) tl)))
      (((catch_all_ref ?l) . ?rst)
       (multiple-value-bind (c tl)
          (get-catches/tl rst)
          (values (cons (cons #x03 l) c) tl)))
      (else (values '() l))))

(define (get-names/locals/tl l)
   (match-case l
      (((local (and (? symbol?) ?name (not (? valtype-symbol?))) ?type) . ?rst)
       (multiple-value-bind (n t tl) (get-names/locals/tl rst)
          (values (cons name n) (cons type t) tl)))
      (((local . ?types) . ?rst)
       (multiple-value-bind (n t tl) (get-names/locals/tl rst)
          (values (append (map (lambda (-) (fresh-var)) types) n)
                  (append types t) tl)))
      (else (values '() '() l))))

(define (get-fieldnames l)
   (match-case l
      (((field (and (? symbol?) ?name (not (? valtype-symbol?))) ?-) . ?rst)
       (cons name (get-fieldnames rst)))
      (((field . ?types) . ?rst)
       (append (map (lambda (-) (fresh-var)) types) (get-fieldnames rst)))
      (() '())))

(define (get-fields l)
   (match-case l
      (((field (and (? symbol?) (not (? valtype-symbol?))) ?t) . ?rst)
       (cons t (get-fields rst)))
      (((field . ?types) . ?rst)
       (append types (get-fields rst)))
      (() '())))

(define (remove-names-comptype t)
   (match-case t
      ((func . ?rst)
       (multiple-value-bind (- p r -)
          (get-names/params/results/tl t)
          `(func (param ,@p) (result ,@r))))
      ((struct . ?fds) `(struct (field ,@(get-fields fds))))
      (else t)))

(define (remove-names-subtype st)
   (match-case st
      ((sub final . ?rst)
        (multiple-value-bind (idxs ct)
          (get-typeidxs/comptype rst)
          `(sub final ,@idxs ,(remove-names-comptype ct))))
      ((sub . ?rst)
       (multiple-value-bind (idxs ct)
          (get-typeidxs/comptype rst)
          `(sub ,@idxs ,(remove-names-comptype ct))))
      (else (remove-names-comptype st))))

(define (write-string n out-port)
   (leb128-write-unsigned (string-length n) out-port)
   (display n out-port))

(define (write-vec v wr out-port)
   (leb128-write-unsigned (length v) out-port)
   (for-each (lambda (x) (wr x out-port)) v))

;; actually also works on heap types to avoid other boilerplate functions, might
;; change that
(define (write-valtype typeidxs t out-port)
   (match-case t
      ((? valtype-symbol?)
       (write-byte (hashtable-get *valtype-symbols* t) out-port))
      ((? type-abbreviation?)
       (write-valtype typeidxs (hashtable-get *type-abbreviations* t) out-port))
      ((? symbol?)
       (if (hashtable-contains? typeidxs t)
           (leb128-write-signed (hashtable-get typeidxs t) out-port)
           (error "write-valtype" "unknown type" t)))
      ((ref ?t)
       (write-byte #x64 out-port)
       (write-valtype typeidxs t out-port))
      ((ref null ?t)
       (write-byte #x63 out-port)
       (write-valtype typeidxs t out-port))))

;; the following function expect comptypes to be in the form given by
;; remove-names-comptype, i.e. (func (param ...) (result ...)),
;; (struct (field ...)), or (array ...)
(define (write-comptype typeidxs t out-port)
   (define (write-fieldtype t out-port)
      (match-case t
         ((mut ?t)
          (write-valtype typeidxs t out-port)
          (write-byte #x01 out-port))
         (else
          (write-valtype typeidxs t out-port))))
   (match-case t
      ((func (param . ?p) (result . ?r))
       (write-byte #x60 out-port)
       (write-vec p (lambda (t p) (write-valtype typeidxs t p)) out-port)
       (write-vec r (lambda (t p) (write-valtype typeidxs t p)) out-port))
      ((array ?t)
       (write-byte #x5E out-port)
       (write-fieldtype t out-port))
      ((struct (field . ?fds))
       (write-byte #x5F out-port)
       (write-vec fds write-fieldtype out-port))))

(define (write-subtype typeidxs st out-port)
   (match-case st
      ((sub final . ?rst)
       (multiple-value-bind (idxs ct)
          (get-typeidxs/comptype rst)
          (unless (null? idxs)
             (write-byte #x4F out-port)
             (write-vec
              idxs
              (lambda (x p)
                 (leb128-write-unsigned (hashtable-get typeidxs x) p))
              out-port))
          (write-comptype typeidxs ct out-port)))
      ((sub . ?rst)
       (multiple-value-bind (idxs ct)
          (get-typeidxs/comptype rst)
          (write-byte #x4F out-port)
          (write-vec
           idxs
           (lambda (x p)
              (leb128-write-unsigned (hashtable-get typeidxs x) p))
           out-port)
          (write-comptype typeidxs ct out-port)))
      (else (write-comptype typeidxs st out-port))))

(define (write-rectype typeidxs rt out-port)
   (define (write-typedef td out-port)
      (match-case td
         ((type (and (? symbol?) ?name) ?st)
          (write-subtype typeidxs (remove-names-subtype st) out-port))
         ((type ?st)
          (write-subtype typeidxs (remove-names-subtype st) out-port))))
   (match-case rt
      ((rec . ?v)
       (write-byte #x4E out-port)
       (write-vec v write-typedef out-port))
      (else (write-typedef rt out-port))))

(define (write-globaltype typeidxs gt out-port)
   (match-case gt
      ((mut ?vt)
       (write-valtype typeidxs vt out-port)
       (write-byte #x01 out-port))
      (else (write-valtype typeidxs gt out-port)
            (write-byte #x00))))

(define (write-section secid in-port out-port vec-len)
   (let* ((len (call-with-output-string
                  (lambda (p) (leb128-write-unsigned vec-len p))))
          (content (string-append len (close-output-port in-port)))
          (size (string-length content)))
      ; only one byte indicates that we have a 0 length vector (the only byte is
      ; the size of the vector), which means we can omit the section
      (unless (= size 1)
         (write-byte secid out-port)
         (write-string content out-port))))

(define (write-module m out-port)
   (let ((typep (open-output-string))
         (importp (open-output-string))
         (funcp (open-output-string))
         (exportp (open-output-string))
         (codep (open-output-string))
         (globalp (open-output-string))
         (memp (open-output-string))
         (tagp (open-output-string))
         (datap (open-output-string))
         (typeidxs (make-hashtable))
         (funcidxs (make-hashtable))
         (globalidxs (make-hashtable))
         (tagidxs (make-hashtable))
         (memidxs (make-hashtable))
         (fieldidxs (make-hashtable))
         (dataidxs (make-hashtable))
         (defined-types (create-hashtable :eqtest equal?))
         (ntypes 0)
         (nimports 0)
         (ncodes 0)
         (nfuncs 0)
         (nexports 0)
         (nglobals 0)
         (nmems 0)
         (ndata 0)
         (ntags 0))

      (define (index x l i)
            (cond ((null? l) (error "index" "unknown identifier" x))
                  ((eq? (car l) x) i)
                  (#t (index x (cdr l) (+ 1 i)))))

      (define (fieldidx t f)
         (index f (hashtable-get fieldidxs t) 0))

      (define (funcidx f)
         (cond ((symbol? f) (hashtable-get funcidxs f))
               ((number? f) f)
               (#t (error "funcidx" "unknown function" f))))

      (define (typeidx t)
         (cond ((symbol? t) (hashtable-get typeidxs t))
               ((number? t) t)
               (#t (error "typeidx" "unknown type" t))))

      (define (globalidx x)
         (cond ((symbol? x) (hashtable-get globalidxs x))
               ((number? x) x)
               (#t (error "globalidx" "unknown global" x))))

      (define (memidx x)
         (cond ((symbol? x) (hashtable-get memidxs x))
               ((number? x) x)
               (#t (error "memidx" "unknown memory" x))))

      (define (tagidx x)
         (cond ((symbol? x) (hashtable-get tagidxs x))
               ((number? x) x)
               (#t (error "tagidx" "unknown tag" x))))

      (define (dataidx x)
         (cond ((symbol? x) (hashtable-get dataidxs x))
               ((number? x) x)
               (#t (error "dataidx" "unknown data" x))))

      (define (get-typeidx! t)
         (let ((h (hashtable-get defined-types t)))
            (if h
                h
                (begin
                   (hashtable-put! defined-types t ntypes)
                   (set! ntypes (+ 1 ntypes))
                   (- ntypes 1)))))

      (define (update-tables! m)
         (match-case m
            ; only support named imports for the moment (didn't find a use-case
            ; yet for unnamed imports)
            ((import ?- ?- (func (and ?id (? symbol?)) . ?-))
             (hashtable-put! funcidxs id nfuncs)
             (set! nfuncs (+ 1 nfuncs))
             (set! nimports (+ 1 nimports))
             (list m))
            ((import ?- ?- (global (and ?id (? symbol?)) . ?-))
             (hashtable-put! globalidxs id nglobals)
             (set! nglobals (+ 1 nglobals))
             (set! nimports (+ 1 nimports))
             (list m))
            ((export . ?-)
             (set! nexports (+ 1 nexports))
             (list m))
            ((type ?name ?st)
             (let* ((t (remove-names-subtype st))
                    (id (get-typeidx! t)))
                (hashtable-put! typeidxs name id)
                (match-case st
                   ((or (sub final ??- (struct . ?fds)) (sub ??- (struct . ?fds))
                        (struct . ?fds))
                    (hashtable-put! fieldidxs name (get-fieldnames fds))))
                (if (= id (- ntypes 1)) ; has t already been defined ?
                    (list `(type ,name ,t))
                    '())))
            ((rec . ?lst)
             (list `(rec ,@(map car (remove null? (map update-tables! lst))))))
            ((func (export (and ?nm (? string?))) . ?rst)
             (update-tables! `(func ,(fresh-var) (export ,nm) ,@rst)))
            ((func (and (? symbol?) ?id) (export (and ?nm (? string?))) . ?rst)
             (append (update-tables! `(export ,nm (func ,id)))
                     (update-tables! `(func ,id ,@rst))))
            ((func (and (? symbol?) ?id) (import (and ?nm1 (? string?))
                                                 (and ?nm2 (? string?))) . ?tu)
             (update-tables! `(import ,nm1 ,nm2 (func ,id ,@tu))))
            ((func (and ?id (? symbol?)) . ?-)
             (hashtable-put! funcidxs id nfuncs)
             (set! nfuncs (+ 1 nfuncs))
             (set! ncodes (+ 1 ncodes))
             (list m))
            ((global (and (? symbol?) ?id) (import (and ?nm1 (? string?))
                                                   (and ?nm2 (? string?)) ?gt))
             (update-tables! `(import ,nm1 ,nm2 (global ,id ,gt))))
            ((global (export (and ?nm (? string?))) . ?rst)
             (update-tables! `(global ,(fresh-var) (export ,nm) ,@rst)))
            ((global (and (? symbol?) ?id) (export (and ?nm (? string?))) .
                     ?rst)
             (append (update-tables! `(export ,nm (global ,id)))
                     (update-tables! `(global ,id ,@rst))))
            ((global (and (? symbol?) ?id) . ?-)
             (hashtable-put! globalidxs id nglobals)
             (set! nglobals (+ 1 nglobals))
             (list m))
            ((memory (and (? symbol?) ?id) . ?limits)
             (hashtable-put! memidxs id nmems)
             (set! nmems (+ 1 nmems))
             (list `(memory ,@limits)))
            ((memory . ?-)
             (set! nmems (+ 1 nmems))
             (list m))
            ((tag (and (? symbol?) ?id) . ?tu)
             (hashtable-put! tagidxs id ntags)
             (set! ntags (+ 1 ntags))
             (list `(tag ,@tu)))
            ((tag . ?-)
             (set! ntags (+ 1 ntags))
             (list m))
            ((data (and (? symbol?) ?id) . ?d)
             (hashtable-put! dataidxs id ndata)
             (set! ndata (+ 1 ndata))
             (list `(data ,@d)))
            ((data . ?-)
             (set! ndata (+ 1 ndata))
             (list m))
            (else (error "update-table!" "unknown declaration" m))))

      ;; returns an id for the typeuse, a list of names for the parameters and
      ;; the rest of the program
      (define (write-typeuse! tu)
         (match-case tu
            ; to validate we should check that the eventual params/results are
            ; correct, when no params/results are given, we should generate
            ; dummy names, but the (type x) syntax is not used in bigloo
            (((type ?x) . ?rst)
             (multiple-value-bind (n - - tl)
                (get-names/params/results/tl rst)
                (values (typeidx x) n tl)))
            ; we have params/results
            (else
             (multiple-value-bind (n p r tl) (get-names/params/results/tl tu)
                (let* ((t `(func (param ,@p) (result ,@r)))
                       (id (get-typeidx! t)))
                   (if (= id (- ntypes 1)) ; has t already been defined ?
                       (write-comptype typeidxs t typep))
                   (values id n tl))))))

      (define (write-import-desc! d)
         ; todo : tag memory table - not used in bigloo
         (match-case d
            ((or (func (? symbol?) . ?tu) (func . ?tu))
             (multiple-value-bind (id - -) (write-typeuse! tu)
                (write-byte #x00 importp)
                (leb128-write-unsigned id importp)))
            ((or (global (? symbol?) ?gt) (global ?gt))
             (begin (write-byte #x03 importp)
                    (write-globaltype typeidxs gt typep)))))

      (define (write-export-desc d)
         ; todo : tag table - not used in bigloo
         (match-case d
            ((func ?f)
             (write-byte #x00 exportp)
             (leb128-write-unsigned (funcidx f) exportp))
            ((memory ?m)
             (write-byte #x01 exportp)
             (leb128-write-unsigned (memidx m) exportp))
            ((global ?x)
             (write-byte #x03 exportp)
             (leb128-write-unsigned (globalidx x) exportp))))

      (define (write-instruction! locals labls i out-port)
         (define (go i)
            (write-instruction! locals labls i out-port))

         (define (labelidx lab)
            (if (number? lab)
                lab
                (index lab labls 0)))

         (define (localidx v)
            (if (number? v)
                v
                (index v locals 0)))

         (define (write-if-branch! bt b)
            (match-case b
               ((then . ?body)
                (begin (write-byte #x04 out-port)
                       (display bt out-port)
                       (for-each go body)))
               (((kwote else) . ?body)
                (begin (write-byte #x05 out-port)
                       (for-each go body)))
               (else (go b))))

         (define (compile-blocktype! p r)
            (match-case (cons p r)
               ((() . ()) "\x40")
               ((() . (?vt))
                (call-with-output-string
                   (lambda (p) (write-valtype typeidxs vt p))))
               (else
                (call-with-output-string
                   (lambda (op)
                      (let* ((t `(func (param ,@p) (result ,@r)))
                             (id (get-typeidx! t)))
                         (if (= id (- ntypes 1)) ; has t already been defined ?
                             (write-comptype typeidxs t typep))
                         (leb128-write-signed id op)))))))

         (match-case i
            ((block (and (? symbol?) ?label) . ?rst)
             (write-instruction! locals (cons label labls)
                                 `(block ,@rst) out-port))
            ((block . ?rst)
             (multiple-value-bind (- p r tl) (get-names/params/results/tl rst)
                (write-byte #x02 out-port)
                (display (compile-blocktype! p r) out-port)
                (for-each go tl)
                (write-byte #x0B out-port)))
            ((loop (and (? symbol?) ?label) . ?rst)
             (write-instruction! locals (cons label labls)
                                 `(loop ,@rst) out-port))
            ((loop . ?rst)
             (multiple-value-bind (- p r tl) (get-names/params/results/tl rst)
                (write-byte #x03 out-port)
                (display (compile-blocktype! p r) out-port)
                (for-each go tl)
                (write-byte #x0B out-port)))
            ((if (and (? symbol?) ?label) . ?rst)
             (write-instruction! locals (cons label labls)
                                 `(if ,@rst) out-port))
            ((if . ?rst)
             (multiple-value-bind (- p r tl) (get-names/params/results/tl rst)
                (let ((bt (compile-blocktype! p r)))
                   (for-each (lambda (b) (write-if-branch! bt b)) tl)
                   (write-byte #x0B out-port))))
            ((throw (and (? idx?) ?exn) . ?tl)
             (for-each go tl)
             (write-byte #x08)
             (leb128-write-unsigned (tagidx exn) out-port))
            ((br (and (? idx?) ?label))
             (write-byte #x0C out-port)
             (leb128-write-unsigned (labelidx label) out-port))
            ((br_if (and (? idx?) ?label) . ?tl)
             (for-each go tl)
             (write-byte #x0D out-port)
             (leb128-write-unsigned (labelidx label) out-port))
            ((br_table . ?rst)
             (define (get-labls/default/tl l)
                (match-case l
                   (((and ?def (? idx?)) (and ?hd (not (? idx?))) . ?tl)
                    (values '() def (cons hd tl)))
                   (((and ?lab (? idx?)) . ?rst)
                    (multiple-value-bind (l d tl) (get-labls/default/tl rst)
                       (values (cons lab l) d tl)))))
             (multiple-value-bind (lab def tl) (get-labls/default/tl rst)
                (for-each go tl)
                (write-byte #x0E out-port)
                (write-vec lab
                           (lambda (l p) (leb128-write-unsigned (labelidx l) p))
                           out-port)
                (leb128-write-unsigned (labelidx def) out-port)))
            ((call (and (? idx?) ?f) . ?tl)
             (for-each go tl)
             (write-byte #x10 out-port)
             (leb128-write-unsigned (funcidx f) out-port))
            ((return_call (and (? idx?) ?f) . ?tl)
             (for-each go tl)
             (write-byte #x12 out-port)
             (leb128-write-unsigned (funcidx f) out-port))
            ((call_ref (and (? idx?) ?t) . ?tl)
             (for-each go tl)
             (write-byte #x14 out-port)
             (leb128-write-unsigned (typeidx t) out-port))
            ((return_call_ref (and (? idx?) ?t) . ?tl)
             (for-each go tl)
             (write-byte #x15 out-port)
             (leb128-write-unsigned (typeidx t) out-port))
            ((try_table (and (? symbol?) ?label) . ?rst)
             (write-instruction! locals (cons label labls)
                                 `(try_table ,@rst) out-port))
            ((try_table . ?rst)
             (write-byte #x1F out-port)
             (multiple-value-bind (- p r tl) (get-names/params/results/tl rst)
                (display (compile-blocktype! p r) out-port)
                (define (write-catch c out-port)
                   (write-byte (car c) out-port)
                   (if (pair? (cdr c))
                       (begin
                          (leb128-write-unsigned (tagidx (cadr c)) out-port)
                          (leb128-write-unsigned (labelidx (cddr c)) out-port))
                       (leb128-write-unsigned (labelidx (cdr c)) out-port)))
                (multiple-value-bind (c tl) (get-catches/tl tl)
                   (write-vec c write-catch out-port)
                   (for-each go tl)
                   (write-byte #x0B out-port))))

            ((global.get ?v . ?tl)
             (for-each go tl)
             (write-byte #x23 out-port)
             (leb128-write-unsigned (globalidx v) out-port))
            ((global.set ?v . ?tl)
             (for-each go tl)
             (write-byte #x24 out-port)
             (leb128-write-unsigned (globalidx v) out-port))
            ((local.get ?v . ?tl)
             (for-each go tl)
             (write-byte #x20 out-port)
             (leb128-write-unsigned (localidx v) out-port))
            ((local.set ?v . ?tl)
             (for-each go tl)
             (write-byte #x21 out-port)
             (leb128-write-unsigned (localidx v) out-port))

            ((i32.const (and (? wnumber?) ?n))
             (write-byte #x41 out-port)
             (leb128-write-signed (wnumber->number n) out-port))
            ((i64.const (and (? wnumber?) ?n))
             (write-byte #x42 out-port)
             (leb128-write-signed (wnumber->number n) out-port))
            ((f32.const (and (? wnumber?) ?n))
             (write-byte #x43 out-port)
             (let* ((m (wnumber->number n))
                    (s (if (fixnum? m)
                           (double->ieee-string (fixnum->flonum m))
                           (double->ieee-string m))))
                (do ((i 3 (- i 1)))
                    (>= i 0)
                   (write-byte (char->integer (string-ref s i))))))
            ((f64.const (and (? wnumber?) ?n))
             (write-byte #x44 out-port)
             (let* ((m (wnumber->number n))
                    (s (if (fixnum? m)
                           (double->ieee-string (fixnum->flonum m))
                           (double->ieee-string m))))
                (do ((i 7 (- i 1)))
                    (>= i 0)
                   (write-byte (char->integer (string-ref s i))))))

            ((ref.null ?ht)
             (write-byte #xD0 out-port)
             (write-valtype typeidxs ht out-port))
            ((ref.func (and (? symbol?) ?f))
             (write-byte #xD2 out-port)
             (leb128-write-unsigned (funcidx f) out-port))
            (((? ref-instruction-typeidx?) ?x . ?tl)
             (for-each go tl)
             (write-byte #xFB out-port)
             (leb128-write-unsigned (hashtable-get *ref-instructions* (car i))
                                    out-port)
             (leb128-write-unsigned (typeidx x) out-port))
            (((or struct.get struct.get_s struct.get_u struct.set) ?x ?y . ?tl)
             (for-each go tl)
             (write-byte #xFB out-port)
             ; maps struct.get to 2, struct.get_s to 3, etc.
             (leb128-write-unsigned
              (index (car i)
                     '(struct.get struct.get_s struct.get_u struct.set) 2)
              out-port)
             (leb128-write-unsigned (typeidx x) out-port)
             (leb128-write-unsigned (fieldidx x y) out-port))
            ((array.new_fixed ?x (and (? wnumber?) ?n) . ?tl)
             (for-each go tl)
             (write-byte #xFB out-port)
             (leb128-write-unsigned 8 out-port)
             (leb128-write-unsigned (typeidx x) out-port)
             (leb128-write-unsigned (wnumber->number n) out-port))
            ((array.new_data ?x ?y . ?tl)
             (for-each go tl)
             (write-byte #xFB out-port)
             (leb128-write-unsigned 9 out-port)
             (leb128-write-unsigned (typeidx x) out-port)
             (leb128-write-unsigned (dataidx y) out-port))
            ((array.copy ?x ?y . ?tl)
             (for-each go tl)
             (write-byte #xFB out-port)
             (leb128-write-unsigned 17 out-port)
             (leb128-write-unsigned (typeidx x) out-port)
             (leb128-write-unsigned (typeidx y) out-port))
            ((ref.test (ref ?ht) . ?tl)
             (for-each go tl)
             (write-byte #xFB out-port)
             (leb128-write-unsigned 20 out-port)
             (write-valtype typeidxs ht out-port))
            ((ref.cast (ref ?ht) . ?tl)
             (for-each go tl)
             (write-byte #xFB out-port)
             (leb128-write-unsigned 22 out-port)
             (write-valtype typeidxs ht out-port))

            (((and ?op (? opcode?)) . ?tl)
             (for-each go tl)
             (let ((code (hashtable-get *simple-opcodes* op)))
                (if (list? code)
                    (for-each (lambda (b) (write-byte b out-port)) code)
                    (write-byte code out-port))))

            (else (error "write-instruction" "unknown instruction" i))))

      (define (out-mod m)
         (match-case m
            ((import (and ?mod (? string?)) (and ?nm (? string?)) ?d)
             (write-string mod importp)
             (write-string nm importp)
             (write-import-desc! d))
            ((export (and ?nm (? string?)) ?d)
             (write-string nm exportp)
             (write-export-desc d))
            ((or (type . ?-) (rec . ?-))
             (write-rectype typeidxs m typep))
            ;; todo : rewrite, maybe put in a function aside
            ((func (? symbol?) . ?rst)
             (multiple-value-bind (id par-nms tl) (write-typeuse! rst)
                (multiple-value-bind (loc-nms loc-tys body)
                                     (get-names/locals/tl tl)
                   (leb128-write-unsigned id funcp)
                   ; we are wasting space on local declaration, as two i32
                   ; variables will be declared as one i32 local twice (that's
                   ; what indicates the write-byte 1), instead of being a single
                   ; declaration of two i32 locals
                   (let* ((loc-decl
                           (call-with-output-string
                              (lambda (p)
                                 (write-vec loc-tys
                                    (lambda (t p)
                                       (write-byte #x01 p)
                                       (write-valtype typeidxs t p)) p))))
                          (code
                           (call-with-output-string
                              (lambda (p)
                                 (for-each
                                  (lambda (i)
                                     (write-instruction!
                                      (append par-nms loc-nms) '() i p))
                                   body)
                                 (write-byte #x0B p))))
                          (cont (string-append loc-decl code)))
                      (write-string cont codep)))))
            ((global (? symbol?) ?gt . ?expr)
             (write-globaltype typeidxs gt globalp)
             (for-each (lambda (i) (write-instruction! '() '() i globalp)) expr)
             (write-byte #x0B globalp))
            ((memory (and (? number?) ?n))
             (write-byte #x00 memp)
             (leb128-write-unsigned n memp))
            ((memory (and (? number?) ?n) (and (? number?) ?m))
             (write-byte #x01 memp)
             (leb128-write-unsigned n memp)
             (leb128-write-unsigned m memp))
            ((data . ?d)
             (leb128-write-unsigned 1 datap)
             (write-string (apply string-append d) datap))
            ((tag . ?tu)
             (multiple-value-bind (id - -) (write-typeuse! tu)
                (write-byte #x00 tagp)
                (leb128-write-unsigned id tagp)))))

      (let ((desuggared-mods (map update-tables! (cddr m))))
         (for-each (lambda (l) (for-each out-mod l)) desuggared-mods))

      (display "\x00asm\x01\x00\x00\x00" out-port) ; magic and version
      (write-section #x01 typep out-port ntypes)
      (write-section #x02 importp out-port nimports)
      (write-section #x03 funcp out-port ncodes)
      (write-section #x05 memp out-port nmems)
      (write-section #x06 globalp out-port nglobals)
      (write-section #x07 exportp out-port nexports)
      (write-section #x0A codep out-port ncodes)
      (write-section #x0D tagp out-port ntags)))

(define (main argv)
   (call-with-input-file (cadr argv)
     (lambda (ip)
        (call-with-output-file "out.wasm"
           (lambda (op)
              (write-module (read ip) op))))))
