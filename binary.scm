(module binary
   (import leb128))

(define (write-string n out-port)
   (leb128-write-unsigned (string-length n) out-port)
   (display n out-port))

(define (write-vec v wr out-port)
   (leb128-write-unsigned (length v) out-port)
   (for-each (lambda (x) (wr x out-port))))

(define (write-valtype types t out-port)
   (match-case t
      ((i32) (write-byte #x7F out-port))
      ((i64) (write-byte #x7E out-port))
      ((f32) (write-byte #x7D out-port))
      ((f64) (write-byte #x7C out-port))
      ((v128) (write-byte #x7B out-port))
      ; these two are not valtypes but we do not validate
      ((i8) (write-byte #x78 out-port))
      ((i16) (write-byte #x77 out-port))
      ((nofunc) (write-byte #x73 out-port))
      ((noextern) (write-byte #x72 out-port))
      ((none) (write-byte #x71 out-port))
      ((func) (write-byte #x70 out-port))
      ((extern) (write-byte #x6F out-port))
      ((any) (write-byte #x6E out-port))
      ((eq) (write-byte #x6D out-port))
      ((i31) (write-byte #x6C out-port))
      ((struct) (write-byte #x6B out-port))
      ((array) (write-byte #x6A out-port))
      ((? symbol?) (leb128-write-signed (hashtable-get types t) out-port))
      ((ref ?t) (begin (write-byte #x64 out-port)
                       (write-valtype types t out-port)))
      ((ref null ?t) (begin (write-byte #x63 out-port)
                            (write-valtype types t out-port)))))

(define (write-comptype types t out-port)
   (define (write-fieldtype t)
      (match-case t
         ((mut ?t) (begin (write-valtype types t out-port)
                          (write-byte #x01 out-port)))
         (else (write-valtype types t out-port))))
   (define (clean-field fd)
      (match-case fd
         ((or (field (? symbol?) ?ft) (field ?ft)) ft)))
   (define (get-params/results::pair l)
      (match-case l
         (() (cons '() '()))
         ; we don't support named parameters yet, they are not used by bigloo
         (((param . ?p) . ?rst)
          (let ((tl (get-params/results rst)))
             (cons (append p (car tl)) (cdr tl))))
         (((result . ?r) . ?rst)
          (let ((tl (get-params/results rst)))
             (cons (car tl) (append r (cdr tl)))))))
   (match-case t
      ((func . ?rst)
       (let* ((p/r (get-params/results rst))
              (p (car p/r))
              (r (cdr p/r)))
          (write-byte #x60 out-port)
          (write-vec p (lambda (t) (write-valtype types t out-port)) out-port)
          (write-vec r (lambda (t) (write-valtype types t out-port)) out-port)))
      ((array ?t) (begin (write-byte #x5E out-port)
                         (write-fieldtype t)))
      ((struct . ?fds)
       (begin (write-byte #x5F out-port)
              (write-vec (map clean-field fds) write-fieldtype out-port)))))

(define (write-subtype types st out-port)
   (define (get-typeidxs/comptype l)
      (match-case l
         ((?ct) (values '() ct))
         ((?x . ?rst)
          (multiple-value-bind (idxs ct)
             (get-typeidxs/comptype rst)
             (values (cons (hashtable-get types x) idxs) ct)))))
   (match-case st
      ((sub final . ?rst)
       (multiple-value-bind (idxs ct)
          (get-typeidxs/comptype rst)
          (unless (null? idxs)
             (write-byte #x4F out-port)
             (write-vec idxs (lambda (x) (leb128-write-unsigned x out-port))
                        out-port))
          (write-comptype types ct out-port)))
      ((sub . ?rst)
       (multiple-value-bind (idxs ct)
          (get-typeidxs/comptype rst)
          (write-byte #x4F out-port)
          (write-vec idxs (lambda (x) (leb128-write-unsigned x out-port))
                     out-port)
          (write-comptype types ct out-port)))
      (else (write-comptype types st out-port))))

(define (write-rectype types rt out-port)
   (define (write-typedef td)
      (match-case td
         ((or (type (? symbol?) ?st) (type ?st))
          (write-subtype types st out-port))))
   (match-case rt
      ((rec . ?v) (begin (write-byte #x4E out-port)
                         (write-vec v write-typedef out-port)))
      (else (write-typedef rt))))

(define (write-section secid in-port out-port)
   (write-byte secid out-port)
   (let* ((content (get-output-string in-port))
          (size (string-length content)))
      (unless (= size 0) ; empty sections can be omitted
         (write-byte secid out-port)
         (write-string content out-port))))

(define (write-module m out-port)
   (let ((typep (open-output-string))
         (importp (open-output-string))
         (types (make-hashtable))
         (ntypes 0)
         (nfuncs 0))
      (write "\x00asm\x01\x00\x00\x00" out-port) ; magic and version
      (define (out-mod m)
         (match-case m
            ((import) '())))
      ))
